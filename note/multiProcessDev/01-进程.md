## table of contents
- [程序](#程序)
- [进程](#进程)
- [单/多道程序](#单多道程序)
- [时间片](#时间片)
- [并行/并发](#并行并发)
- [进程控制块](#进程控制块)
- [进程状态](#进程状态)
- [进程号和相关函数](#进程号和相关函数)

## [程序](#table-of-contents)
```text
程序是使用计算机能够理解的语言书写的一连串命令。


程序包括程序的数据（就是包含了程序的数据，加载后被CPU直接执行）和非程序的数据（包含了程序中所用到的数据）。程序的数据是交给机器执行的。程序的数据会在准备执行时，映射到内存中，成为可以执行的程序。


程序中包含了一系列的信息，这些信息描述了程序如何在运行时创建一个进程：

二进制格式标识：每个程序文件都包含用于描述可执行文件格式的元信息。内核利用此信息来解释文件中的其他信息。（ELF可执行连接格式）

机器语言指令：对程序算法进行编码。

程序入口地址：标识程序开始执行时的起始指令位置。

数据：程序文件包含的变量初始值和程序使用的字面量值（比如字符串）。

符号表及重定位表：描述程序中函数和变量的位置及名称。这些表格有多重用途，其中包括调试和运行时的符号解析（动态链接）。

共享库和动态链接信息：程序文件所包含的一些字段，列出了程序运行时需要使用的共享库，以及加载共享库的动态连接器的路径名。

其他信息：程序文件还包含许多其他信息，用以描述如何创建进程。
```

## [进程](#table-of-contents)
```text
进程是正在运行的程序的实例。是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。

可以用一个程序来创建多个进程，进程是由内核定义的抽象实体，并为该实体分配用以执行程序的各项系统资源。

从内核的角度看，进程由用户内存空间和一系列内核数据结构组成，其中用户内存空间包含了程序代码及代码所使用的变量，而内核数据结
构则用于维护进程状态信息。记录在内核数据结构中的信息包括许多与进程相关的标识号（IDs）、虚拟内存表、打开文件的描述符表、信号传递及处理的有关信息、进程资源使用及限制、当前工作目录和大量的其他信息。
```

## [单/多道程序](#table-of-contents)
```text
单道程序，即在计算机内存中只允许一个的程序运行。

多道程序设计技术是在计算机内存中同时存放几道相互独立的程序，使它们在管理程序控制下，相互穿插运行，两个或两个以上程序在计算机系统中同处于开始到结束之间的状态, 这些程序共享计算机系统资源。引入多道程序设计技术的根本目的是为了提高 CPU 的利用率。

对于一个单 CPU 系统来说，程序同时处于运行状态只是一种宏观上的概念，他们虽然都已经开始运行，但就微观而言，任意时刻，CPU 上运行的程序只有一个。

在多道程序设计模型中，多个进程轮流使用 CPU。而当下常见 CPU 为纳秒级，1秒可以执行大约 10 亿条指令。由于人眼的反应速度是毫秒级，所以看似同时在运行。
```

## [时间片](#table-of-contents)
```text
时间片是 CPU 分配给各个程序的时间，每个程序被分配一个时间段，称作它的时间片，即该程序允许运行的时间。

事实上，虽然一台计算机通常可能有多个 CPU，但是同一个 CPU 永远不可能真正地同时运行多个任务。在只考虑一个 CPU 的情况下，这些进程“看起来像”同时运行的，实则是轮番穿插地运行。

时间片由操作系统内核的调度程序分配给每个进程。首先，内核会给每个进程分配相等的初始时间片，然后每个进程轮番地执行相应的时间，当所有进程都处于时间片耗尽的状态时，内核会重新为每个进程计算并分配时间片，如此往复。
```

## [并行/并发](#table-of-contents)
```text
并行是指两个或多个事件在同一时刻发生；并发是指两个或多个事件在同一时间间隔发生。

并行是在多台处理器上同时执行多个任务，而并发是在一台处理器上“同时”执行多个任务。

并行是真正的同时发生，而并发是假的同时发生。
```

## [进程控制块](#table-of-contents)
```text
进程控制块（Process Control Block，PCB）是操作系统用于记录进程信息的数据结构，也是操作系统中最重要的数据结构之一。

在 /usr/src/linux-headers-xxx/include/linux/sched.h 中定义了 struct task_struct，这个结构体就是 PCB。
```

> `task_struct` 结构体非常复杂，包含许多成员。一些主要的成员包括：
- `state`：进程状态
- `exit_state`：退出状态
- `pid`：进程标识符
- `flags`：进程标记符
- `stack`：进程内核栈
- `parent`、`children`、`sibling` 等：进程亲属关系成员
- `prio`、`static_prio`、`normal_prio` 等：进程优先级
- `policy`：调度策略
- `mm`、`active_mm`：进程地址空间
- `signal`、`blocked`、`sigpending` 等：信号处理相关成员
- `files`、`fs` 等：文件相关成员
- `io_context`: I/O 调度的信息

## [进程状态](#table-of-contents)
```text
进程的状态是指进程所处的状态，它反映了进程所处的生命周期。

在三态模型中，进程状态分为三个基本状态，即就绪态，运行态，阻塞态。
在五态模型中，进程分为新建态、就绪态，运行态，阻塞态，终止态。

在 Linux 中，进程状态有以下几种：
- `TASK_RUNNING`：可执行状态，进程正在执行或者准备执行。
- `TASK_INTERRUPTIBLE`：可中断的睡眠状态，进程正在睡眠，等待某个事件的发生，当该事件发生时，进程会被唤醒，进入可执行状态。
- `TASK_UNINTERRUPTIBLE`：不可中断的睡眠状态，进程正在睡眠，等待某个事件的发生，当该事件发生时，进程会被唤醒，进入可执行状态。
- `TASK_STOPPED`：暂停状态，进程暂停执行。
- `TASK_TRACED`：被跟踪状态，进程被跟踪。
- `EXIT_ZOMBIE`：僵尸状态，进程已经终止，但是其父进程还没有调用 wait() 系统调用来获取其终止状态。
- `EXIT_DEAD`：死亡状态，进程已经终止，其父进程已经调用 wait() 系统调用来获取其终止状态。
```


> 查看进程状态
```shell
# ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.2 168764  5328 ?        Ss   10:49   0:00 /sbin/init
```

> ps 可选参数
```text
a：显示终端上的所有进程，包括其他用户的进程。
u：以用户为主的格式来显示进程状态。
x：显示所有进程，不以终端机来区分。
j：用任务格式来显示进程状态。
```
> 使用命令 `ps -help` 查看 ps 的所有参数

> STAT 状态
```text
S：可中断的睡眠状态，进程正在睡眠，等待某个事件的发生，当该事件发生时，进程会被唤醒，进入可执行状态。
R：可执行状态，进程正在执行或者准备执行。
D：不可中断的睡眠状态，进程正在睡眠，等待某个事件的发生，当该事件发生时，进程会被唤醒，进入可执行状态。
T：暂停状态，进程暂停执行。
Z：僵尸状态，进程已经终止，但是其父进程还没有调用 wait() 系统调用来获取其终止状态。
W：被跟踪状态，进程被跟踪。
X：死亡状态，进程已经终止，其父进程已经调用 wait() 系统调用来获取其终止状态。
N：低优先级的进程。
<：高优先级的进程。
s: 包含子进程的进程。
+：位于前台的进程。
```
> 使用命令 `man ps` 查看 ps 的所有状态

> 进程状态转换
```text
就绪态 -> 运行态：进程调度程序从就绪队列中选择一个进程，将其装入内存，分配资源，建立PCB，将其状态改为运行态，然后将控制权交给该进程，使其开始执行。
运行态 -> 就绪态：进程调度程序从运行队列中选择一个进程，将其状态改为就绪态，然后将控制权交给进程调度程序。
运行态 -> 阻塞态：正在执行的进程因为某些原因（如等待I/O）而无法继续执行时，将其状态改为阻塞态，然后将控制权交给进程调度程序。
阻塞态 -> 就绪态：进程等待的事件已经发生，将其状态改为就绪态，然后将控制权交给进程调度程序。
运行态 -> 终止态：进程执行完毕或者出现异常，将其状态改为终止态，然后将控制权交给进程调度程序。
```

## [进程号和相关函数](#table-of-contents)
```text
进程号是进程的唯一标识符，每个进程都有一个进程号，类型为 pid_t ,它由内核分配，范围是 1 ~ 32767。

进程号为 0 的进程是调度进程，也称为 swapper 进程，它是内核的一部分，不执行任何用户进程，它的作用是在系统初始化时创建第一个进程，然后将控制权交给第一个进程。
进程号为 1 的进程是 init 进程，它是用户进程，是所有进程的祖先进程，它的作用是创建其他进程，当一个进程终止时，它的父进程会接收到一个信号，如果父进程没有处理该信号，那么 init 进程会接收到该信号，init 进程会处理该信号，然后将该进程的状态改为终止态。

任何进程（除 init 进程）都是由另一个进程创建，该进程称为被创建进程的父进程，对应的进程号称为父进程号（PPID）。

进程组是一个或多个进程的集合。他们之间相互关联，进程组可以接收同一终端的各种信号，关联的进程有一个进程组号（PGID）。默认情况下，当前的进程号会当做当前的进程组号。
```
> 可以通过如下函数查看进程号、父进程号、进程组号
```c
#include <unistd.h>
pid_t getpid(void); // 获取当前进程号
pid_t getppid(void); // 获取当前父进程号
pid_t getpgid(pid_t pid); // 获取指定进程号的进程组号
```